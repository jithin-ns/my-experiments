Best practice is: you do NOT ‚Äúmanually‚Äù regenerate tokens at all.
With MSAL the library handles refresh automatically ‚Äî your job is just to always call acquireTokenSilent when you need a token.

Here is the clean, correct pattern for React + MSAL.


---

üîë Key principle (very important)

> Never cache or track access-token expiry yourself.
Always ask MSAL for a token when you need one.



MSAL will:

Return a valid cached access token if it‚Äôs still valid

Automatically use the hidden refresh token if expired

Fall back to interactive login only if required



---

‚úÖ Correct way to refresh access tokens

1Ô∏è‚É£ Store the authenticated account (once)

After login, set the active account:

const { instance } = useMsal();

await instance.loginPopup(loginRequest);

const account = instance.getAllAccounts()[0];
instance.setActiveAccount(account);

> This is important ‚Äî acquireTokenSilent depends on an active account.




---

2Ô∏è‚É£ Always call acquireTokenSilent before API calls

Do NOT do this only in Login component.

Create a central token helper.

tokenService.ts

import { InteractionRequiredAuthError } from "@azure/msal-browser";
import { msalInstance } from "./msalInstance";

const tokenRequest = {
  scopes: ["api://<api-client-id>/access_as_user"]
};

export async function getAccessToken(): Promise<string> {
  const account = msalInstance.getActiveAccount();

  if (!account) {
    throw new Error("No active account. User not logged in.");
  }

  try {
    const response = await msalInstance.acquireTokenSilent({
      ...tokenRequest,
      account
    });

    return response.accessToken;

  } catch (error) {
    if (error instanceof InteractionRequiredAuthError) {
      const response = await msalInstance.acquireTokenPopup(tokenRequest);
      return response.accessToken;
    }
    throw error;
  }
}


---

3Ô∏è‚É£ Use it everywhere (API calls, effects, services)

const token = await getAccessToken();

fetch("/api/data", {
  headers: {
    Authorization: `Bearer ${token}`
  }
});

MSAL automatically:

Checks cache

Refreshes silently

Returns a fresh token if needed



---

‚ùå What NOT to do

‚ùå Do NOT store expiresOn

‚ùå Do NOT manually refresh tokens

‚ùå Do NOT re-login users on expiry

‚ùå Do NOT store access tokens in localStorage yourself

‚ùå Do NOT decode token to check expiry


MSAL already does all of this correctly.


---

üß† Why this works

In SPA:

Refresh tokens are not exposed

MSAL stores them securely

Token refresh happens via hidden iframe + OAuth flow



---

üîÑ What happens on refresh failure

If:

User session expired

Consent needed

Conditional Access triggered


MSAL throws:

InteractionRequiredAuthError

You must then call:

acquireTokenPopup() // or acquireTokenRedirect()


---

üß™ Bonus: handle token refresh globally

For Axios:

axios.interceptors.request.use(async config => {
  const token = await getAccessToken();
  config.headers.Authorization = `Bearer ${token}`;
  return config;
});


---

üîö Final answer

‚úîÔ∏è Best way to generate a new access token:
Always call acquireTokenSilent() when you need a token.

‚úîÔ∏è MSAL handles expiration and refresh automatically.
‚úîÔ∏è You don‚Äôt need timers, expiry checks, or manual refresh logic.


---

If you want, I can:

Review your current Login component

Help move auth logic out of UI components

Provide a production-ready MSAL architecture for React


Just tell me.



import { PublicClientApplication, EventType } from "@azure/msal-browser";

// MSAL configuration
export const msalConfig = {
  auth: {
    clientId: import.meta.env.VITE_CLIENT_ID,
    authority: `https://login.microsoftonline.com/${import.meta.env.VITE_TENANT_ID}`,
    redirectUri: window.location.origin,
  },
  cache: {
    cacheLocation: "localStorage",   // or "sessionStorage"
    storeAuthStateInCookie: false,
  },
};

// Create ONE singleton MSAL instance
export const msalInstance = new PublicClientApplication(msalConfig);

// Optional but recommended: set active account automatically
msalInstance.addEventCallback((event) => {
  if (
    event.eventType === EventType.LOGIN_SUCCESS &&
    event.payload?.account
  ) {
    msalInstance.setActiveAccount(event.payload.account);
  }
});





const re = /^(?:[A-Za-z0-9]+|_+)$/;

const re = /^(?:[A-Za-z0-9]+|_{10})$/;
