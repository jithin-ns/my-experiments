Yes — and in fact there are several clean ways to have your GitHub Actions workflow provide environment-specific values to your Vite + React app without using import.meta.env in your app code (so your tests won't choke on it). The two most common, robust approaches are:

1. Create a runtime config.json (recommended) — Actions writes public/config.json during the workflow or deploy step; app fetches it at runtime before mounting.


2. Inject a global JS config into index.html — Actions replaces a placeholder or writes a small config.js in public/ that sets window.__APP_CONFIG__.



Both avoid bundling values into the build files as import.meta.env and let your tests remain simple. Below I give working GitHub Actions snippets + the React + TypeScript code examples for each approach, plus pros/cons and a short note about test-mocking if you prefer to keep import.meta.env.

Option A — Runtime public/config.json (recommended)

Why: Works well for static hosts (S3, Netlify, Vercel static site, GitHub Pages). Your CI/deploy writes public/config.json (or you upload it alongside build output). App loads it at runtime — tests can mock the fetch or supply a test config file.

GitHub Actions snippet (write config and build)

Put this in .github/workflows/build.yml (example):

name: Build

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install
        run: npm ci

      - name: Create runtime config
        run: |
          mkdir -p public
          cat > public/config.json <<EOF
          {
            "API_URL": "${{ secrets.API_URL }}",
            "CLIENT_ID": "${{ secrets.PUBLIC_CLIENT_ID }}"
          }
          EOF

      - name: Build
        run: npm run build

> Note: public/config.json will be included in the built static output (Vite copies public/). Do not store secrets here that must remain confidential.



React (TypeScript) — load before mount

Create a tiny bootstrap that fetches config then renders the app so components can access it synchronously.

src/config.ts

export type AppConfig = {
  API_URL: string;
  CLIENT_ID?: string;
};

declare global {
  interface Window { __APP_CONFIG__?: AppConfig; }
}

export const getConfigFromWindow = (): AppConfig | undefined => window.__APP_CONFIG__;

export const loadConfig = async (): Promise<AppConfig> => {
  // Try window first (for SSR-ish or dev)
  if (window.__APP_CONFIG__) return window.__APP_CONFIG__ as AppConfig;

  const resp = await fetch('/config.json', { cache: 'no-store' });
  if (!resp.ok) throw new Error('Failed to load config');
  const cfg = await resp.json() as AppConfig;
  window.__APP_CONFIG__ = cfg;
  return cfg;
};

src/main.tsx

import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import { loadConfig } from './config';

async function bootstrap() {
  try {
    const cfg = await loadConfig();
    // optionally set in some Context or global store
    // e.g., React Context provider can receive cfg
    const container = document.getElementById('root')!;
    const root = createRoot(container);
    root.render(<App />);
  } catch (e) {
    // show nicer error page in production if config fails
    console.error('Failed to load app config', e);
  }
}
bootstrap();

Usage in components

import { getConfigFromWindow } from './config';
const apiUrl = getConfigFromWindow()?.API_URL;

Pros

Config can be changed on the server after build (if you overwrite config.json on the host).

Easy to test: tests can set window.__APP_CONFIG__ or stub fetch.

Avoids Vite env system entirely in app code.


Cons

config.json is public — do not put sensitive secrets.



---

Option B — Inject a global JS snippet in index.html

Why: Useful if you prefer a small JS file instead of JSON (e.g., to avoid CORS or to load faster). Workflow writes public/config.js with a single line that sets window.__APP_CONFIG__ = {...}. The app can read window.__APP_CONFIG__ immediately — no fetch.

Workflow example (write config.js)

- name: Create runtime JS config
  run: |
    mkdir -p public
    cat > public/config.js <<EOF
    window.__APP_CONFIG__ = {
      API_URL: "${{ secrets.API_URL }}",
      CLIENT_ID: "${{ secrets.PUBLIC_CLIENT_ID }}"
    };
    EOF

Include <script src="/config.js"></script> in your index.html or simply rely on Vite copying public/config.js (and index.html will include it if present in public/ and referenced).

In index.html add before main.js:

<script src="/config.js"></script>
<script type="module" src="/src/main.tsx"></script>

Pros

No fetch() needed; config available synchronously.

Simpler in some environments.


Cons

Still public; must be careful about secret leakage.



---

Option C — Build-time injection (baked into bundle) — only if not secret

If values are safe to be public and you want them bundled, Actions can create .env.production or set VITE_ prefixed env vars during build. You said you want to avoid import.meta.env, so I’m skipping details — but it’s the classic approach (you already know about it).


---

Quick note about tests (Vitest/Jest) if you ever want to keep import.meta.env

If import.meta.env is the problem in tests, another simple fix is to mock it for tests:

Vitest: setupTests.ts

Object.defineProperty(import.meta, 'env', {
  value: { VITE_API_URL: 'http://localhost:3000' },
});

Jest (ts-jest) You can set a global in jest setup files: globalThis.importMeta = { env: { ... } } or more commonly mock Vite envs via process.env mapping.

But since you want to avoid import.meta.env, the runtime-config options above are the better long-term design.


---

Recommendation

Use Option A (runtime config.json) if you want easy testability and the ability to change configuration after build. It’s robust for static-hosted SPAs and works seamlessly with GitHub Actions.

Use Option B (config.js) if you want synchronous availability (no pre-mount async) and don't want to await a fetch.



---

If you want, I can:

Produce a complete copy-paste GitHub Actions workflow tailored to your repo (and hosting target), and a src/bootstrap example that wires config into a React Context so the whole app can consume it.

Or give the exact Vitest/Jest setup to mock import.meta.env if you decide to keep it.


Which would you like next?
